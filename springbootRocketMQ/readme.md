1. 基础知识
    同步和异步指的是方法的同步异步。
    举例子：方法A调用方法B，需要等到方法B执行完成返回数据后，方法A才能够继续执行。
    这是同步。 异步的话指的是A发出了调用B方法后，立即返回，继续执行A的方法。
    阻塞和非阻塞指的是线程的阻塞非阻塞。
2. 关于消息队列
    优点：
    1. 异步。
        三个优点都建立在异步这个主要特征上，没有异步不可能有应用解耦和雪峰填谷。
    异步指的是方法的异步。(介绍同步异步阻塞非阻塞)。例子见资料。更有说服力的例子，注册
    成功后，发送邮件，发送短信，写数据库一系列操作。
    2. 削峰填谷。
        这种应用场景在于处理短时间高并发的场景，比如熟悉的秒杀项目，搞活动等，将这些请求到达后，
    存放到了MQ当中，后台的服务器慢慢的从MQ中接受消息进行处理。
    3. 应用解耦。
        以电商系统为例子，用户购买商品。调用订单系统，库存系统，物流系统。
     如果有一个模块失败，整个系列都失败了，如果使用消息队列，那就下单完成。
     主要目的是将多个模块拆开，降低系统的耦合。
     
     缺点：
    1. 系统复杂度升高。
    2. 系统可用性降低。
    3. 消息机制产生的问题  (1)消息顺序性  (2)消息丢失 (3) 消息一致性 (4)消息重复消费
   
3. RocketMQ的角色
    消息生产者：producer，消息生产者，web-service中web是生产者。
    消息服务器：broker，经纪人。实现接收、提供、持久化、过滤消息。
    消息消费者：consumer。消费消息，web-service中service是消费者。
    上述三个角色都可以搭建集群，实现高可用；
    监听器监听broker，消费者监听broker，有消息就消费
    偏移量（offset）：消费者需要从代理服务器中获取消息，消费使用；消费完之后并没有删除，而是打了一个已经消费完的标签；偏移量记录的就是所有已经消费过的数据的编码。
    命名服务器：NameServer [cluster]，统筹管理前前三个角色
    broker将自己注册进NameServer
    producer、consumer通过其获取broker信息然后发送、接收消息
    命名服务器NameServer通过心跳检测确认producer、consumer、broker上下线（哥仨向NameServer，30s/次发送心跳）
    消息组成：消息体（body）、主题（Topic）、标签（tag子主题）
    broker组成：内含多个不同主题（Topic），每个topic中包含多个队列(默认4个)


4. 关于MQ的集群知识。
    四种角色都能够集群。生产者集群 消费者集群 NameServer注册服务器集群 Broker服务器集群
    (1) NameServer 是一个无状态的节点，可集群部署，节点都是各自独立的，无任何信息同步。
    (2) ① Broker 分为 Master 与 Slave，一个 Master 可以对应多个 Slave，但一个 Slave 只能对应一个Master；
        ② Master 与 Slave 的对应关系通过指定相同的 BrokerName，不同的 BrokerID 来定义，id 为 0 表示 Master， 非 0 表示 Slave；
        ③ 可以部署多个 Master 实现 Broker 集群，即多组 Master - Slave 的 Broker 节点；
        ④ Master 通常用于写入数据，Slave 用于读取数据；
        ⑤ 每个 Broker 与 NameServer 集群中的所有节点建立长连接，定时注册 Topic 信息到所有 NameServer；
    (3) 集群配置
        1. 单Master模式。风险很大，一旦Broker重启或者宕机服务不可用。
        2. 多Master模式。但是没有Slave。配置简单。单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息消费的实时性会受到影响。
        3. 多Master多Slave模式-异步复制
        每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：
        优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样。
        缺点：Master宕机，磁盘损坏情况下会丢失少量消息。
        4. 多Master多Slave模式-同步双写
        每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：
        优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；
        缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高。
    （4）MQ的刷盘机制。
        同步刷盘和异步刷盘。
        1）同步刷盘
        在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。
        2）异步刷盘
        在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。
    （5）RocketMQ主从复制机制
        1）同步复制
        同步复制方式是等Master和Slave均写成功后，才反馈给客户端写成功状态；
        在同步复制方式下，如果Master出故障， Slave上有全部的备份数据，容易恢复，但是同步复制会增大数据写入延迟，降低系统吞吐量。
        2）异步复制
        异步复制方式是只要Master写成功，即可反馈给客户端写成功状态。
        在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写入Slave，有可能会丢失；
    (6) 实践方案。
    通常情况下，应该把Master和Save配置成ASYNC_FLUSH（异步刷盘）的刷盘方式，主从之间配置成SYNC_MASTER（同步复制）的复制方式，这样即使有一台机器出故障，仍然能保证数据不丢，是个不错的选择。
    
    (7) 关于消费
    1、在Rocket集群消费模式下，（订阅）同一个主题（Topic）下的消息，对于不同的消费者组是一种“广播形式”，即每个消费者组的都会消费消息。
    2、在Rocket集群消费模式下，（订阅）同一个主题（Topic）下的消息，对于相同的消费者组的消费者而言是一种集群模式，即同一个消费者组内的所有消费者均分消息并消费

   
   
   
   
   
   
   
   
   
   
   
   
   
    
3. 学习消息队列的疑问。
    1. 消息队列的数据存储到哪了。
        (1) 文件系统，MQ拿到消息后，进行持久化的时候通过同步刷盘，异步刷屏的方法持久化。
        写的文件系统中。 RocketMQ Kafka
        (2) 分布式KV存储，redis的列表list也可以作为消息队列的一种实现方法。
        对消息读写能力要求并不高的情况下使用。
        (3) 直接使用DB完成。比如ActiveMQ。但是数据库还是会出现瓶颈的尤其在千万级别。
        如果DB故障，MQ的消息无法罗盘导致线上故障。但是ActiveMQ的客户端支持的语言丰富。
        
    