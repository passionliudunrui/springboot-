1. 基础知识
    同步和异步指的是方法的同步异步。
    举例子：方法A调用方法B，需要等到方法B执行完成返回数据后，方法A才能够继续执行。
    这是同步。 异步的话指的是A发出了调用B方法后，立即返回，继续执行A的方法。
    阻塞和非阻塞指的是线程的阻塞非阻塞。
2. 关于消息队列
    优点：
    1. 异步。
        三个优点都建立在异步这个主要特征上，没有异步不可能有应用解耦和雪峰填谷。
    异步指的是方法的异步。(介绍同步异步阻塞非阻塞)。例子见资料。更有说服力的例子，注册
    成功后，发送邮件，发送短信，写数据库一系列操作。
    2. 削峰填谷。
        这种应用场景在于处理短时间高并发的场景，比如熟悉的秒杀项目，搞活动等，将这些请求到达后，
    存放到了MQ当中，后台的服务器慢慢的从MQ中接受消息进行处理。
    3. 应用解耦。
        以电商系统为例子，用户购买商品。调用订单系统，库存系统，物流系统。
     如果有一个模块失败，整个系列都失败了，如果使用消息队列，那就下单完成。
     主要目的是将多个模块拆开，降低系统的耦合。
     
     缺点：
    1. 系统复杂度升高。
    2. 系统可用性降低。
    3. 消息机制产生的问题  (1)消息顺序性  (2)消息丢失 (3) 消息一致性 (4)消息重复消费
   
3. RocketMQ的角色
    消息生产者：producer，消息生产者，web-service中web是生产者。
    消息服务器：broker，经纪人。实现接收、提供、持久化、过滤消息。
    消息消费者：consumer。消费消息，web-service中service是消费者。
    上述三个角色都可以搭建集群，实现高可用；
    监听器监听broker，消费者监听broker，有消息就消费
    偏移量（offset）：消费者需要从代理服务器中获取消息，消费使用；消费完之后并没有删除，而是打了一个已经消费完的标签；偏移量记录的就是所有已经消费过的数据的编码。
    命名服务器：NameServer [cluster]，统筹管理前前三个角色
    broker将自己注册进NameServer
    producer、consumer通过其获取broker信息然后发送、接收消息
    命名服务器NameServer通过心跳检测确认producer、consumer、broker上下线（哥仨向NameServer，30s/次发送心跳）
    消息组成：消息体（body）、主题（Topic）、标签（tag子主题）
    broker组成：内含多个不同主题（Topic），每个topic中包含多个队列(默认4个)


4. 关于MQ的集群知识。
    四种角色都能够集群。生产者集群 消费者集群 NameServer注册服务器集群 Broker服务器集群
    (1) NameServer 是一个无状态的节点，可集群部署，节点都是各自独立的，无任何信息同步。
    (2) ① Broker 分为 Master 与 Slave，一个 Master 可以对应多个 Slave，但一个 Slave 只能对应一个Master；
        ② Master 与 Slave 的对应关系通过指定相同的 BrokerName，不同的 BrokerID 来定义，id 为 0 表示 Master， 非 0 表示 Slave；
        ③ 可以部署多个 Master 实现 Broker 集群，即多组 Master - Slave 的 Broker 节点；
        ④ Master 通常用于写入数据，Slave 用于读取数据；
        ⑤ 每个 Broker 与 NameServer 集群中的所有节点建立长连接，定时注册 Topic 信息到所有 NameServer；
    (3) 集群配置
        1. 单Master模式。风险很大，一旦Broker重启或者宕机服务不可用。
        2. 多Master模式。但是没有Slave。配置简单。单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息消费的实时性会受到影响。
        如果使用了RAID10磁盘阵列，即使宕机，RAID10磁盘高可靠，消息不会丢失，异步刷盘丢失一点数据。
        3. 多Master多Slave模式-异步复制
        每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：
        优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样。
        缺点：Master宕机，磁盘损坏情况下会丢失少量消息，因为是异步复制。
        4. 多Master多Slave模式-同步双写
        每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：
        优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；
        缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高。
        但是最重要的是，目前版本，master宕机后，slave不能自动切换master。
    （4）MQ的刷盘机制。
        同步刷盘和异步刷盘。
        1）同步刷盘
        在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。
        2）异步刷盘
        在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。
    （5）RocketMQ主从复制机制
        1）同步复制
        同步复制方式是等Master和Slave均写成功后，才反馈给客户端写成功状态；
        在同步复制方式下，如果Master出故障， Slave上有全部的备份数据，容易恢复，但是同步复制会增大数据写入延迟，降低系统吞吐量。
        2）异步复制
        异步复制方式是只要Master写成功，即可反馈给客户端写成功状态。
        在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写入Slave，有可能会丢失；
    (6) 实践方案。
    通常情况下，应该把Master和Save配置成ASYNC_FLUSH（异步刷盘）的刷盘方式，主从之间配置成SYNC_MASTER（同步复制）的复制方式，这样即使有一台机器出故障，仍然能保证数据不丢，是个不错的选择。
    最佳实践。看资料图。
    
    (7) 关于消费
    1、在Rocket集群消费模式下，（订阅）同一个主题（Topic）下的消息，对于不同的消费者组是一种“广播形式”，即每个消费者组的都会消费消息。
    2、在Rocket集群消费模式下，（订阅）同一个主题（Topic）下的消息，对于相同的消费者组的消费者而言是一种集群模式，即同一个消费者组内的所有消费者均分消息并消费

    (8) 复制策略
    同步复制，消息写入master，master等他slave同步数据成功后向produce返回成功ack。
    异步复制，消息写入master后,master立即向produce返回成功ack，无需等待slave同步数据成功。
    同步刷盘，消息持久化到broker的磁盘后才算消息写入成功。
    异步刷盘，消息写入到broker的内存后表示写入成功,无需等待消息持久化到磁盘。
    注意异步的时候，是消息写入到了broker的内存，一般是pageCache。当pageCache一定量的时候自动落盘。
    
5. MQ工作原理。
    1. 消费幂等问题。
        (1) 消费者对某条消息进行重复消费的情况时候，重复消费的结果和消费一次的结果是相同的，并且多次消费。
        并未对业务产生影响，这个消费过程是消费幂等。 尤其在网络不稳定的情况下，消息很有可能重复发送或者消费。
        (2) 实际场景。
        1. 发送时候消息重复。当一个消息发送到broker并且完成持久化，网络山东，broker对producer应答失败。
        然后producer会尝试再次发送到这消息重复。MessageID相同。
        2. 消费时候消息重复。消息投递到consumer并完成业务处理，反馈ack的时候网路动荡。broker没有接收到消费成功，
        保证消息至少消费一次，broker在网络恢复的时候会重新投递已经被处理过的消息。
        3. rebalance的时候消息重复。
        consumer数量变化或者queue数量变化或者网络动荡导致nameserver连接出现问题。
        触发热balance。可能会消费重复的消息。MessageID相同。
    2. 消息幂等的解决方案。
        1. 两个要素。幂等令牌和唯一性处理。
        2. 具体解决方法。
            1. 首先通过缓存去重。如果缓存中已经存在了某幂等令牌，说明本次操作是重复操作。如果缓存没有命中，则进入下一步。
            2. 在唯一性处理之前，先在数据库查询幂等令牌作为索引的数据是否存在，如果存在说明本次操作为重复性操作，不存在进入下一步。
            因为缓存有个过期时间（淘汰机制）。
            3. 在同一个事务中完成三项操作。唯一性处理后将幂等令牌写到缓存，并将幂等令牌作为唯一索引的数据写入db。
        3. 支付场景举例子。
        资料图。
        
6. 事务消息
    


5. 小tips
    1. 消费者只能监听一个topic的消息，只能消费一个topic的消息。
    2. 一个topic的queue中的消息只能被一个消费者组中的一个消费者消费。
    3. 生产者组是同一类生产者的结合。这类producer发送相同的topic消息。
    一个生产者可以同时发送多个主题的消息。
    4. 容错机制。当消费者组中有个消费者挂了之后，这个消费者的监听的消息会
    分发给其他的消费者。 
    5. Broker存储消费进度便宜offset topic queue。
    6. Master负责处理读写操作请求。Slace负责堆Master数据备份。
    当Master挂了的话，会切换成Slave工作，是主备集群而不是主从集群。
    相同的brokeName 但是brokeId不同 master是0 slave是1
    7. RocketMQ能够保证消息不丢失，但是不能保证消息不重复。
    
    
   
   
   
   
   
   
   
   
   
   
   
   
    
3. 学习消息队列的疑问。
    1. 消息队列的数据存储到哪了。
        (1) 文件系统，MQ拿到消息后，进行持久化的时候通过同步刷盘，异步刷屏的方法持久化。
        写的文件系统中。 RocketMQ Kafka
        (2) 分布式KV存储，redis的列表list也可以作为消息队列的一种实现方法。
        对消息读写能力要求并不高的情况下使用。
        (3) 直接使用DB完成。比如ActiveMQ。但是数据库还是会出现瓶颈的尤其在千万级别。
        如果DB故障，MQ的消息无法罗盘导致线上故障。但是ActiveMQ的客户端支持的语言丰富。
        
    